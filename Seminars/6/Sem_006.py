# Задача. 
# Найти палиндром через рекурсию.

# def is_palindrome(s):
#     if len(s) <= 1:
#         return True
#     else:
#         # Проверяем, что первый и последний символы строки совпадают
#         if s[0] == s[-1]:
#             # Вызываем функцию рекурсивно для подстроки без первого и последнего символов
#             return is_palindrome(s[1:-1])
#         else:
#             return False

# # Пример использования функции:
# print(is_palindrome("radar"))  # Вывод: True
# print(is_palindrome("hello"))  # Вывод: False
# print(is_palindrome("12321"))

# -------------------------------

# def palindrom(stroka):
#     if len(stroka) <= 1:
#         return True
#     if stroka[0]!=stroka[-1]:
#         return False
#     return palindrom(stroka[1:-1])
           
# print(palindrom("qwewq"))


# ----------------------------------------------------

# Задача №45. Общее обсуждение
'''
Два различных натуральных числа n и m называются
дружественными, если сумма делителей числа n
(включая 1, но исключая само n) равна числу m и
наоборот. Например, 220 и 284 – дружественные числа.
По данному числу k выведите все пары дружественных
чисел, каждое из которых не превосходит k. Программа
получает на вход одно натуральное число k, не
превосходящее 105
. Программа должна вывести все
пары дружественных чисел, каждое из которых не
превосходит k. Пары необходимо выводить по одной в
строке, разделяя пробелами. Каждая пара должна быть
выведена только один раз (перестановка чисел новую
пару не дает).

Ввод:  300
Вывод: 220 284
'''

# N = int(input())
# kor = list()

# for i in range(N):
#     d = 0
#     for j in range(1, i):
#         if i % j == 0:
#             d += j
#     kor.append(tuple([i,d]))

# # print(kor)

# for i in range(len(kor)):
#     for j in range(i, len(kor)):
#         if i!=j and kor[i][0] == kor[j][1] and kor[i][1] == kor[j][0]:
#             print(kor[i])

# -------------------------------

# k = 300

# def sum_of_dividors(n):
#     s = 0
#     for k in range(1, n // 2 + 1):
#         if n % k == 0:
#             s += k
#     return s

# for i in range(1, k + 1):
#     j = sum_of_dividors(i)
#     if i < j <= k and i == sum_of_dividors(j):
#         print(i, j)


# -----------------------------------------------------

# Задача. Орел и решка
'''
Дана строка текста, состоящая из букв русского алфавита "О" и "Р". 
Буква "О" – соответствует выпадению Орла, а буква "Р" – соответствует выпадению Решки. 
Напишите программу, которая подсчитывает наибольшее количество подряд выпавших Решек.
Формат входных данных
На вход программе подается строка текста, состоящая из букв русского алфавита "О" и "Р".
Формат выходных данных
Программа должна вывести наибольшее количество подряд выпавших Решек.
Примечание. Если выпавших Решек нет, то необходимо вывести число
0
0.
'''

def max_consecutive_heads(string):
    max_count = 0  # Макс. количество подряд выпавших решек
    current_count = 0  # Текущее количество подряд выпавших решек
    for char in string:
        if char == 'Р':
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0  # Обнуляем счетчик при выпадении орла
    return max_count

# Считываем строку
coin_flips = input("Введите строку из букв 'О' и 'Р': ")

# Выводим результат
print(max_consecutive_heads(coin_flips))

